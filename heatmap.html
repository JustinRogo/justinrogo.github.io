<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Multi-Floor Occupancy Heatmap (Embedded Images)</title>
    <style>
        :root {
            --bg: #0b1020;
            --panel: #0b1226;
            --line: #1e293b
        }

        [hidden] {
            display: none !important;
        }


        body {
            margin: 0;
            background: var(--bg);
            color: #e5e7eb;
            font: 14px system-ui, Segoe UI, Roboto, Helvetica, Arial
        }

        header,
        footer {
            display: flex;
            gap: .5rem;
            align-items: center;
            padding: .65rem;
            border-bottom: 1px solid var(--line);
            background: var(--panel);
            flex-wrap: wrap
        }

        footer {
            border-top: 1px solid var(--line);
            border-bottom: none;
            justify-content:space-around
            
        }


        button,
        label,
        input[type="range"],
        select {
            background: #121b33;
            border: 1px solid #26324d;
            color: #e5e7eb;
            border-radius: 8px;
            padding: .4rem .6rem
        }

        button:disabled {
            opacity: .5
        }

        .row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
           
        }

        #wrap {
            position: relative;
            width: 100%;
            height: calc(100dvh - 152px);
            touch-action: none
        }

        #floor,
        #heat {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block
        }

        #heat {
            pointer-events: none
        }

        .tabs {
            display: flex;
            flex-wrap: nowrap;
            /* prevent wrapping */
            gap: 0.5rem;
            flex: 1;
        }

        .notes-wrap {
            display: flex;
            flex-direction: column;
            width:550px;
            min-width: 240px;
            flex: 1
        }

        #notes {
            resize: horizontal;
            min-height: 40px;
            max-height: 160px;
            background: #0b1226;
            border: 1px solid #26324d;
            color: #e5e7eb;
            border-radius: 8px;
            padding: .5rem .6rem;
            font: 14px system-ui;
        }



        .tab {
            flex: 1;
            /* let them grow evenly */
            text-align: center;
            font-size: 1.1rem;
            /* larger text */
            font-weight: 600;
            padding: 0.75rem 1.25rem;
            /* larger hit area */
            border-radius: 10px;
            border: 1px solid #26324d;
            background: #1b2550;
            cursor: pointer;
            transition: background 0.2s;
        }

        .tab:hover {
            background: #243074;
        }

        .tab.active {
            background: #2563eb;
            /* bright blue like submit */
            border-color: #1e40af;
            color: #fff;
        }



        .badge {
            margin-left: .35rem;
            padding: .05rem .4rem;
            border-radius: 999px;
            background: #243152;
            border: 1px solid #3a4b73;
            font-size: 12px
        }

        small {
            opacity: .7
        }

        .submitbtn {
            margin-left: auto;
            /* pushes it to the far right */
            font-size: 1.1rem;
            /* bigger text */
            padding: 0.75rem 1.5rem;
            /* larger click area */
            background: #2563eb;
            /* bright blue background */
            border-color: #1e40af;
            font-weight: 600;
        }

        .submitbtn:hover {
            background: #1d4ed8;
        }

        .iconbtn {
            margin-left: auto;
            font-size: 1.2rem;
            padding: .4rem .6rem
        }

        .panel {
            position: fixed;
            top: 56px;
            right: 12px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: .5rem;
            background: #0b1226;
            border: 1px solid #26324d;
            border-radius: 10px;
            padding: .6rem .8rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, .35);
        }

        .panel label {
            white-space: nowrap
        }
    </style>
</head>

<body>
    <header class="row">
        <button id="menuBtn" type="button" class="iconbtn" aria-expanded="false"
            aria-controls="controlsPanel">☰</button>
        <div class="tabs" id="tabs"></div>
<div style="font-size: 1.5em;"><strong>Total Count:</strong> <span id="totalCount">0</span></div>

     
        


    </header>

    <div id="wrap">
        <canvas id="floor"></canvas>
        <canvas id="heat"></canvas>
    </div>

    <footer>
        <div class="row">
            <button id="undo" disabled>Undo</button>
            <button id="clear" disabled>Clear this floor</button>
            <button id="resetAll">Reset all floors</button>
            
            <label class="notes-wrap">
                Notes
                <textarea id="notes" rows="2" placeholder="Optional note for this submission"></textarea>
            </label>
   <button id="submit" class="submitbtn">Submit & Save<small id="status"></small></button>
        </div>


        <!-- header stays, without the slider labels -->

        <div id="controlsPanel" class="panel" hidden>
            <label>Radius <input id="radius" type="range" min="8" max="80" value="50"></label>
            <label>Intensity <input id="intensity" type="range" min="5" max="200" value="150"></label>
            <label>Opacity <input id="opacity" type="range" min="10" max="100" value="80"></label>
            <label>Blur <input id="blur" type="range" min="0" max="30" value="8"></label>
            <div class="row">
                <label>Load JSON <input id="loadJSON" type="file" accept="application/json"></label>
                <label>Load JSONs <input id="loadMany" type="file" accept="application/json" multiple></label>
                <label>From <input id="from" type="datetime-local"></label>
                <label>To <input id="to" type="datetime-local"></label>
                <label><input id="includeSessions" type="checkbox" checked> Include loaded</label>


            </div>
        </div>

    </footer>

    <script>

        (() => {
            // --- Embedded floor images (replace placeholders) ------------------------
            const EMBEDDED = {
                '1F': 'https://raw.githubusercontent.com/JustinRogo/justinrogo.github.io/refs/heads/main/Maps/1F.png',
                '2F': 'https://raw.githubusercontent.com/JustinRogo/justinrogo.github.io/refs/heads/main/Maps/2F.png',
                '3F': 'https://raw.githubusercontent.com/JustinRogo/justinrogo.github.io/refs/heads/main/Maps/3F.png',
                '4F': 'https://raw.githubusercontent.com/JustinRogo/justinrogo.github.io/refs/heads/main/Maps/4F.png',
                '5F': 'https://raw.githubusercontent.com/JustinRogo/justinrogo.github.io/refs/heads/main/Maps/5F.png',
            };

            // --- Floors ---------------------------------------------------------------
            const FLOORS = [
                { id: '1F', label: '1st Floor', img: new Image(), imgSrc: null, points: [] },
                { id: '2F', label: '2nd Floor', img: new Image(), imgSrc: null, points: [] },
                { id: '3F', label: '3rd Floor', img: new Image(), imgSrc: null, points: [] },
                { id: '4F', label: '4th Floor', img: new Image(), imgSrc: null, points: [] },
                { id: '5F', label: '5th Floor', img: new Image(), imgSrc: null, points: [] },
            ];
            let current = 0;

            // Sessions loaded for trend review
            const SESSIONS = []; // {ts: Date, floors:[{id, image_data_url?, points:[]}]} 

            // --- Elements -------------------------------------------------------------
            const wrap = document.getElementById('wrap');
            const floor = document.getElementById('floor');
            const heat = document.getElementById('heat');
            const fctx = floor.getContext('2d');
            const hctx = heat.getContext('2d');
            const undoBtn = document.getElementById('undo');
            const clearBtn = document.getElementById('clear');
            const exportCSV = document.getElementById('exportCSV');
            const resetAll = document.getElementById('resetAll');
            const submitBtn = document.getElementById('submit');
            const statusEl = document.getElementById('status');
            const radiusEl = document.getElementById('radius');
            const intenEl = document.getElementById('intensity');
            const opacEl = document.getElementById('opacity');
            const blurEl = document.getElementById('blur');
            const loadJSON = document.getElementById('loadJSON');
            const loadMany = document.getElementById('loadMany');
            const fromEl = document.getElementById('from');
            const toEl = document.getElementById('to');
            const includeSessionsEl = document.getElementById('includeSessions');
            // Put near top with other config
            const FLOW_URL = "https://default17f1a87e2a254eaab9df9d439034b0.80.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/8a4d2abd61de4fceb5cb6d2a4b2b31a8/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=EhX0b_ECMsXs08oSiwPJKO3H5KMRI3O0l3V1lLtdM6Q";
            const notesEl = document.getElementById('notes');


            // Tabs with counters
            const tabs = document.getElementById('tabs');
            FLOORS.forEach((fl, i) => {
                const b = document.createElement('button');
                b.className = 'tab' + (i === 0 ? ' active' : '');
                b.innerHTML = `${fl.label} <span class="badge" id="count-${fl.id}">0</span>`;
                b.onclick = () => { current = i; updateTabs(); fitCanvas(); redraw(); };
                tabs.appendChild(b);
            });
            function updateTabs() {
                tabs.querySelectorAll('.tab').forEach((el, idx) =>
                    el.classList.toggle('active', idx === current));
            }

            // Preload embedded images
            FLOORS.forEach(fl => {
                if (EMBEDDED[fl.id]) {
                    fl.imgSrc = EMBEDDED[fl.id];
                    fl.img.src = EMBEDDED[fl.id];
                }
                // also update when images decode
                fl.img.onload = () => { if (FLOORS[current] === fl) { fitCanvas(); redraw(); } persist(); };
            });

            // Resize handling
            window.addEventListener('resize', () => { fitCanvas(); redraw(); });

            // Input: only inside fitted image rect
            wrap.addEventListener('pointerdown', e => {
                const fl = FLOORS[current];
                if (!fl.img.naturalWidth) return;
                const rect = floor.getBoundingClientRect();
                const px = e.clientX - rect.left, py = e.clientY - rect.top;

                const fit = imageFitRect(fl.img.naturalWidth, fl.img.naturalHeight, floor.width, floor.height);
                if (px < fit.x || px > fit.x + fit.w || py < fit.y || py > fit.y + fit.h) return;

                const x = (px - fit.x) * (fl.img.naturalWidth / fit.w);
                const y = (py - fit.y) * (fl.img.naturalHeight / fit.h);

                fl.points.push({ x, y, t: Date.now() });
                persist(); redraw();
            });

            undoBtn.onclick = () => { FLOORS[current].points.pop(); persist(); redraw(); };
            clearBtn.onclick = () => { FLOORS[current].points = []; persist(); redraw(); };



            resetAll.onclick = () => {
                FLOORS.forEach(fl => fl.points = []);
                persist(); redraw();
            };



            async function sendToFlow(payload) {
                const r = await fetch(FLOW_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                });
                if (!r.ok) throw new Error(`${r.status} ${await r.text().catch(() => "")}`);
                return r; // many flows return empty 202/200
            }

            submitBtn.onclick = async () => {
                const payload = {
                    submitted_at: new Date().toISOString(),
                    note: (notesEl?.value || "").trim(),              // <— add this line
                    floors: FLOORS.map(fl => ({
                        id: fl.id,
                        image_data_url: fl.img.naturalWidth ? fl.img.src : null,
                        image_size: fl.img.naturalWidth ? { w: fl.img.naturalWidth, h: fl.img.naturalHeight } : null,
                        points: fl.points
                      
                    })),
                    TotalCount: computeTotalCount()
                };

                statusEl.textContent = " (Sending...)";
                try {
                    await sendToFlow(payload);                         // your existing uploader
                    statusEl.textContent = " (Submitted!)";

                    // reset points only
                    FLOORS.forEach(fl => fl.points = []);
                    persist(); redraw();

                    // clear note
                    if (notesEl) notesEl.value = "";
                } catch (e) {
                    statusEl.textContent = `Flow error: ${e.message}`;
                }
            };



            // Load a single JSON
            loadJSON.onchange = e => {
                const [f] = e.target.files || [];
                if (!f) return;
                f.text().then(txt => {
                    try {
                        const data = JSON.parse(txt);
                        if (!data.floors) throw new Error("Bad format");
                        data.floors.forEach((fl, i) => {
                            if (!FLOORS[i]) return;
                            FLOORS[i].points = Array.isArray(fl.points) ? fl.points : [];
                            if (fl.image_data_url) { FLOORS[i].imgSrc = fl.image_data_url; FLOORS[i].img.src = fl.image_data_url; }
                        });
                        current = 0; updateTabs(); fitCanvas(); redraw();
                        statusEl.textContent = `Loaded ${f.name} (timestamp ${data.submitted_at || "n/a"})`;
                    } catch (err) { alert("Invalid JSON file"); console.error(err); }
                });
            };

            // Load many JSONs for trend review
            loadMany.onchange = async e => {
                const files = Array.from(e.target.files || []);
                if (!files.length) return;
                const texts = await Promise.all(files.map(f => f.text()));
                for (const t of texts) {
                    try {
                        const j = JSON.parse(t);
                        if (!j.floors) continue;
                        const ts = j.submitted_at ? new Date(j.submitted_at) : new Date();
                        SESSIONS.push({ ts, floors: j.floors });
                    } catch { }
                }
                const min = new Date(Math.min(...SESSIONS.map(s => +s.ts)));
                const max = new Date(Math.max(...SESSIONS.map(s => +s.ts)));
                if (isFinite(+min) && isFinite(+max)) { fromEl.value = toLocalDT(min); toEl.value = toLocalDT(max); }
                redraw();
            };
            [fromEl, toEl, includeSessionsEl].forEach(el => el.addEventListener('input', redraw));

            // --- Helpers --------------------------------------------------------------
            function computeTotalCount() {
  let total = 0;
  FLOORS.forEach(fl => {
    let n = fl.points.length;
    for (const sess of filteredSessions()) {
      const sf = (sess.floors || []).find(f => f.id === fl.id);
      if (sf && Array.isArray(sf.points)) n += sf.points.length;
    }
    total += n;
  });
  return total;
}
            function fitCanvas() {
                const rect = wrap.getBoundingClientRect();
                floor.width = Math.max(1, Math.floor(rect.width));
                floor.height = Math.max(1, Math.floor(rect.height));
                heat.width = floor.width; heat.height = floor.height;
                fctx.imageSmoothingEnabled = true;
                fctx.imageSmoothingQuality = 'high';
            }

            function imageFitRect(iw, ih, cw, ch) {
                if (!iw || !ih || !cw || !ch) return { x: 0, y: 0, w: cw, h: ch };
                const s = Math.min(cw / iw, ch / ih);
                const w = Math.floor(iw * s), h = Math.floor(ih * s);
                const x = Math.floor((cw - w) / 2), y = Math.floor((ch - h) / 2);
                return { x, y, w, h };
            }

            function filteredSessions() {
                if (!includeSessionsEl.checked) return [];
                const start = fromEl.value ? new Date(fromEl.value) : new Date(-8640000000000000);
                const end = toEl.value ? new Date(toEl.value) : new Date(8640000000000000);
                return SESSIONS.filter(s => s.ts >= start && s.ts <= end);
            }

            function redraw() {
                const fl = FLOORS[current];

                // aggregate: current points + filtered sessions
                const aggPoints = [...fl.points];
                for (const sess of filteredSessions()) {
                    const sf = (sess.floors || []).find(f => f.id === fl.id);
                    if (sf && Array.isArray(sf.points)) aggPoints.push(...sf.points);
                }

                // buttons state
                undoBtn.disabled = fl.points.length === 0;
                clearBtn.disabled = fl.points.length === 0;

                // clear canvases
                fctx.clearRect(0, 0, floor.width, floor.height);
                hctx.clearRect(0, 0, heat.width, heat.height);

                if (!fl.img.naturalWidth) { updateCounts(); return; }

                // aspect-fit rect and scales
                const fit = imageFitRect(fl.img.naturalWidth, fl.img.naturalHeight, floor.width, floor.height);
                fctx.drawImage(fl.img, 0, 0, fl.img.naturalWidth, fl.img.naturalHeight, fit.x, fit.y, fit.w, fit.h);

                // heat accumulation on downscaled buffer
                const down = 0.5;
                const hw = Math.max(1, (fit.w * down) | 0);
                const hh = Math.max(1, (fit.h * down) | 0);
                const acc = document.createElement('canvas'); acc.width = hw; acc.height = hh;
                const actx = acc.getContext('2d', { willReadFrequently: true });
                actx.clearRect(0, 0, hw, hh);
                actx.globalCompositeOperation = 'lighter';

                const R = +radiusEl.value, I = +intenEl.value, k = down;

                // kernel sprite
                const spr = makeKernelSprite(R);
                const sR = Math.max(2, Math.round(R * k));
                const sprScaled = document.createElement('canvas');
                sprScaled.width = sR * 2; sprScaled.height = sR * 2;
                sprScaled.getContext('2d').drawImage(spr, 0, 0, sprScaled.width, sprScaled.height);

                // map each point into fitted rect
                const iw = fl.img.naturalWidth, ih = fl.img.naturalHeight;
                const sx = fit.w / iw, sy = fit.h / ih;

                for (const p of aggPoints) {
                    const x = p.x * sx * k;
                    const y = p.y * sy * k;
                    actx.globalAlpha = Math.min(1, I / 100);
                    actx.drawImage(sprScaled, x - sR, y - sR);
                }

                // colorize
                const imgData = actx.getImageData(0, 0, hw, hh);
                const data = imgData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const a = data[i + 3] / 255;
                    const [r, g, b] = ramp(a);
                    data[i] = r; data[i + 1] = g; data[i + 2] = b;
                    data[i + 3] = Math.round(255 * (+opacEl.value / 100) * Math.min(1, a * 1.5));
                }
                actx.putImageData(imgData, 0, 0);

                // blur
                const blurPx = +blurEl.value;
                if (blurPx > 0) {
                    const tmp = document.createElement('canvas'); tmp.width = hw; tmp.height = hh;
                    const bctx = tmp.getContext('2d'); bctx.filter = `blur(${blurPx}px)`; bctx.drawImage(acc, 0, 0);
                    actx.clearRect(0, 0, hw, hh); actx.drawImage(tmp, 0, 0);
                }

                // composite to display
                hctx.drawImage(acc, 0, 0, hw, hh, fit.x, fit.y, fit.w, fit.h);

                // QA markers
                fctx.fillStyle = '#111827';
                for (const p of aggPoints) {
                    const mx = fit.x + p.x * sx;
                    const my = fit.y + p.y * sy;
                    fctx.beginPath(); fctx.arc(mx, my, 2.5, 0, Math.PI * 2); fctx.fill();
                }

                updateCounts();
            }

            function makeKernelSprite(R) {
                const c = document.createElement('canvas'); c.width = c.height = R * 2;
                const ctx = c.getContext('2d');
                const g = ctx.createRadialGradient(R, R, 0, R, R, R);
                g.addColorStop(0, 'rgba(0,0,0,1)');
                g.addColorStop(0.3, 'rgba(0,0,0,0.35)');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(R, R, R, 0, Math.PI * 2); ctx.fill();
                return c;
            }

            function ramp(t) {
                // t in [0,1] from accumulated alpha. Optional easing to keep more green:
                let x = Math.max(0, Math.min(1, t));
                x = Math.pow(x, 1); // lower -> more green time

                // Anchors: 0=green, 0.5=yellow, 0.75=orange, 1=red
                const G = [0, 255, 0];
                const Y = [255, 255, 0];
                const O = [255, 165, 0];
                const R = [255, 0, 0];

                const lerp = (a, b, p) => Math.round(a + (b - a) * p);

                let c;
                if (x < 0.5) {
                    const p = x / 0.5;           // 0..1
                    c = [lerp(G[0], Y[0], p), lerp(G[1], Y[1], p), lerp(G[2], Y[2], p)];
                } else if (x < 0.75) {
                    const p = (x - 0.5) / 0.25;  // 0..1
                    c = [lerp(Y[0], O[0], p), lerp(Y[1], O[1], p), lerp(Y[2], O[2], p)];
                } else {
                    const p = (x - 0.75) / 0.25; // 0..1
                    c = [lerp(O[0], R[0], p), lerp(O[1], R[1], p), lerp(O[2], R[2], p)];
                }
                return c;
            }

            function clamp(v) { return Math.max(0, Math.min(255, v)); }

            function download(data, name, type) {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([data], { type: type }));
                a.download = name; a.click();
            }

            function updateCounts() {
                let total = 0;
                FLOORS.forEach(fl => {
                    let n = fl.points.length;
                    for (const sess of filteredSessions()) {
                        const sf = (sess.floors || []).find(f => f.id === fl.id);
                        if (sf && Array.isArray(sf.points)) n += sf.points.length;
                    }
                    total += n;
                    const el = document.getElementById(`count-${fl.id}`);
                    if (el) el.textContent = n;
                });
                const t = document.getElementById('totalCount');
                if (t) t.textContent = total;
            }

            function persist() {
                const minimal = FLOORS.map(fl => ({ id: fl.id, points: fl.points }));
                localStorage.setItem('multi-floor-heatmap-embedded', JSON.stringify(minimal));
            }
            function restore() {
                try {
                    const arr = JSON.parse(localStorage.getItem('multi-floor-heatmap-embedded') || "[]");
                    arr.forEach((o, i) => { if (FLOORS[i]) FLOORS[i].points = o.points || []; });
                } catch { }
            }

            function toLocalDT(d) {
                const pad = n => String(n).padStart(2, '0');
                return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
            }

            // init
            restore();
            fitCanvas();
            redraw();
        })();
        const menuBtn = document.getElementById('menuBtn');      // <button id="menuBtn" …>
        const controlsPanel = document.getElementById('controlsPanel');

        function openPanel() { controlsPanel.removeAttribute('hidden'); menuBtn.setAttribute('aria-expanded', 'true'); }
        function closePanel() { controlsPanel.setAttribute('hidden', ''); menuBtn.setAttribute('aria-expanded', 'false'); }

        menuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const willHide = !controlsPanel.hasAttribute('hidden'); // panel is open -> hide
            controlsPanel.toggleAttribute('hidden', willHide);
            menuBtn.setAttribute('aria-expanded', String(!willHide));
        });

        document.addEventListener('click', (e) => {
            if (!controlsPanel.hasAttribute('hidden') &&
                !controlsPanel.contains(e.target) &&
                e.target !== menuBtn) closePanel();
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !controlsPanel.hasAttribute('hidden')) closePanel();
        });


    </script>
</body>

</html>